<!DOCTYPE html>
<html style="font-size: 16px;">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="​Important Leadership Skills">
    <meta name="description" content="">
    <meta name="page_type" content="np-template-header-footer-from-plugin">
    <title>SRTF</title>
    <link rel="stylesheet" href="nicepage.css" media="screen">
<link rel="stylesheet" href="Simulation.css" media="screen">
    <script class="u-script" type="text/javascript" src="jquery.js" defer=""></script>
    <script class="u-script" type="text/javascript" src="nicepage.js" defer=""></script>
    <meta name="generator" content="Nicepage 4.9.5, nicepage.com">
    <link id="u-theme-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i|Open+Sans:300,300i,400,400i,500,500i,600,600i,700,700i,800,800i">
    <link id="u-page-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i">
    <style>
      body {
        background-image: url('images/bg3.png');
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: 100% 100%;
      }
      </style>
    
    
    <script type="application/ld+json">{
		"@context": "http://schema.org",
		"@type": "Organization",
		"name": ""
}</script>
    <meta name="theme-color" content="#478ac9">
    <meta property="og:title" content="Simulation">
    <meta property="og:type" content="website">
  </head>
  <body data-home-page="Simulation.html" data-home-page-title="Simulation" class="u-body u-xl-mode"><header class="u-clearfix u-header u-header" id="sec-3af7" style="background-color: #5980a1;"><div class="u-clearfix u-sheet u-sheet-1">
        <nav class="u-menu u-menu-dropdown u-offcanvas u-menu-1">
          <div class="menu-collapse" style="font-size: 1rem; letter-spacing: 0px;">
            <a class="u-button-style u-custom-left-right-menu-spacing u-custom-padding-bottom u-custom-top-bottom-menu-spacing u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="#">
              <svg class="u-svg-link" viewBox="0 0 24 24"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#menu-hamburger"></use></svg>
              <svg class="u-svg-content" version="1.1" id="menu-hamburger" viewBox="0 0 16 16" x="0px" y="0px" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><g><rect y="1" width="16" height="2"></rect><rect y="7" width="16" height="2"></rect><rect y="13" width="16" height="2"></rect>
</g></svg>
            </a>
          </div>
          <div class="u-custom-menu u-nav-container">
            <ul class="u-nav u-unstyled u-nav-1"><li class="u-nav-item"><a class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="../../index.html" style="padding: 10px 20px;">Home</a>
</li></ul>
          </div>
          <div class="u-custom-menu u-nav-container-collapse">
            <div class="u-black u-container-style u-inner-container-layout u-opacity u-opacity-95 u-sidenav">
              <div class="u-inner-container-layout u-sidenav-overflow">
                <div class="u-menu-close"></div>
                <ul class="u-align-center u-nav u-popupmenu-items u-unstyled u-nav-2"><li class="u-nav-item"><a class="u-button-style u-nav-link" href="../../index.html">Home</a>
</li></ul>
              </div>
            </div>
            <div class="u-black u-menu-overlay u-opacity u-opacity-70"></div>
          </div>
        </nav>
      </div></header>
    <section class="u-align-left u-clearfix u-grey-5 u-section-1" id="carousel_a616">
      <div class="u-clearfix u-sheet u-sheet-1">
        <h2 class="u-custom-font u-font-montserrat u-text u-text-default u-text-1">Shortest Remaining Time First (SRTF)</h2>
        <div class="u-expanded-width u-tab-links-align-left u-tabs u-tabs-1">
          <ul class="u-spacing-15 u-tab-list u-unstyled" role="tablist">
            <li class="u-tab-item" role="presentation">
              <a class="active u-active-palette-1-base u-button-style u-tab-link u-text-active-white u-text-body-color u-text-hover-grey-75 u-tab-link-1" id="link-tab-0da5" href="#tab-0da5" role="tab" aria-controls="tab-0da5" aria-selected="true">Theory</a>
            </li>
            <li class="u-tab-item" role="presentation" style="font-size: 20px;padding-top: 9px;">
              <a  href="srtf.html">Simulation</a>
            </li>
          </ul>
          <div class="u-tab-content">
            <div class="u-align-left u-container-style u-tab-active u-tab-pane u-white u-tab-pane-1" id="tab-0da5" role="tabpanel" aria-labelledby="link-tab-0da5">
              <div class="u-container-layout u-valign-bottom u-container-layout-1">
                <p class="u-text u-text-2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The Preemptive version of Shortest Job First(SJF) scheduling is known as Shortest Remaining Time First (SRTF). With the help of the SRTF algorithm, the process having the smallest amount of time remaining until completion is selected first to execute.So basically in SRTF, the processes are scheduled according to the shortest remaining time.<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; However, the SRTF algorithm involves more overheads than the Shortest job first (SJF)scheduling, because in SRTF OS is required frequently in order to monitor the CPU time of the jobs in the&nbsp;READY&nbsp;queue and to perform context switching.In the&nbsp;SRTF scheduling algorithm, the execution of any process can be stopped after a certain amount of time. On arrival of every process, the short-term scheduler schedules those processes from the list of available processes &amp; running processes that have the least remaining burst time.<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; After all the processes are available in the ready queue, then, No preemption will be done and then the algorithm will work the same as SJF scheduling. In the Process Control Block, the context of the process is saved, when the process is removed from the execution and when the next process is scheduled. The PCB is accessed on the next execution of this process.<br>
                  <br>
                  <span style="font-size: 1.5rem; font-weight: 700;">Advantages of SRTF&nbsp; :</span>
                  <br>
                  <br>The main advantage of the SRTF algorithm is that it makes the processing of the jobs faster than the SJF algorithm, mentioned it’s overhead charges are not counted.<br>
                  <br>
                  <span style="font-weight: 700; font-size: 1.5rem;">Disadvantages of SRTF&nbsp; :</span>
                  <br>
                  <br>In SRTF, the context switching is done a lot more times than in SJN due to more consumption of the CPU's valuable time for processing. The consumed time of CPU then adds up to its processing time and which then diminishes the advantage of fast processing of this algorithm.<br>
                  <br>
                  <span style="font-weight: 700; font-size: 1.5rem;">Example :&nbsp;</span>
                  <br>
                  <br>
                  <br>
                </p>
                <img class="u-image u-image-1" src="images/srtf_exp.jpeg" data-image-width="636" data-image-height="311">
                <p class="u-text u-text-3">
                  <span style="font-weight: 700; font-size: 1.375rem;">Explanation :&nbsp;</span>
                  <br>1) At the 0th unit of the CPU, there is only one process that is&nbsp;P1, so P1 gets executed for the 1 time unit.<br>2) At the 1st unit of the CPU, Process&nbsp;P2&nbsp;arrives. Now, the&nbsp;P1&nbsp;needs 6 more units more to be executed, and the&nbsp;P2&nbsp;needs only 3 units. So,&nbsp;P2&nbsp;is executed first by preempting&nbsp;P1.<br>3) At the 3rd unit of time, the process&nbsp;P3&nbsp;arrives, and the burst time of P3 is 4 units which is more than the completion time of P2 that is 1 unit, so P2 continues its execution.<br>4) Now after the completion of&nbsp;P2, the burst time of&nbsp;P3&nbsp;is&nbsp;4 units&nbsp;that means it needs only 4 units for completion while P1 needs 6 units for completion.<br>5) So, this algorithm picks&nbsp;P3&nbsp;above&nbsp;P1 due to the reason that the completion time of P3 is less than that of P1<br>6) P3 gets completed at time unit 8, there are no new processes arrived.<br>7) So again,&nbsp;P1&nbsp;is sent for execution, and it gets completed at the 14th unit.<br>
                  <br>As Arrival Time and Burst time for three processes P1, P2, P3 are given in the above diagram. Let us calculate Turn around time, completion time, and waiting time.<br>
                  <br>
                  <br>
                </p>
                <img class="u-image u-image-default u-image-2" src="images/srtf_exp_2.png" alt="" data-image-width="1630" data-image-height="858">
                <p class="u-text u-text-4">Average waiting time is calculated by adding the waiting time of all processes and then dividing them by no. of processes.<br>average waiting time = waiting for time of all processes/ no.of processesaverage waiting time=7+0+1=8/3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&nbsp;2.66ms<br>
                  <br>
                  <span style="font-weight: 700;">
                    <span style="font-size: 1.375rem;"> C program to simulate SRTF algorithm</span>
                  </span>
                  <br>&nbsp;<br>
                  <pre><code class="language-java graf graf--code">
                    #include < stdio.h>
                      #include < stdlib.h>
                      
                      struct os{
                          int pid;
                          int at;
                          int bt;
                          int ct;
                          int tat;
                          int wt;
                          int st;
                          int new_id;
                          int bt_rem;
                       
                      }*ptr[100];
                      
                      int check[200];
                      int checkprocess[200];
                      int k=0,l=0;
                      
                      void gantt_chart( int n){
                          int i;
                          
                          printf("\n\nGannt Chart:\n");
                          for(i=0;i< l; i++){
                             printf("-----------");
                          }
                          printf("\n");
                          for(int i=0;i < l;i++){
                              printf("|    P%d    ",checkprocess[i]+1);
                          }
                          printf("|\n");
                          for(i=0; i< l; i++){
                              printf("-----------");
                          }
                          printf("\n");
                          
                         printf("%d\t   ",ptr[0]->at);
                          
                          for(i=0;i < 10;i++){
                                printf("%d          ",check[i]);       
                          }
                          for(int i=10;i < k;i++){
                              printf("%d         ",check[i]);
                          }
                      }
                      
                      
                      int main(){
                          int n;
                          printf("Enter how many processes : ");
                          scanf("%d", &n);
                          float totalTAT=0, totalWT=0,avgRT=0;
                          int i;
                          int is_completed[100];
                          for(int i=0;i < n;i++){
                              is_completed[i]=0;
                          }
                             printf("-----SRTF----\n");
                          for(i=0;i < n;i++){
                             ptr[i] = (struct os*)malloc(sizeof(struct os));
                              printf("Enter arrivaltime of process %d :",i+1);
                              scanf("%d", &ptr[i]->at);
                              printf("Enter bursttime of process %d :",i+1);
                              scanf("%d", &ptr[i]->bt);
                              ptr[i]->bt_rem = ptr[i]->bt;
                              ptr[i]->pid = i+1;
                          }
                          struct os *temp1;
                          for(i=0;i < n;i++){
                              for(int j=0;j < n-1;j++){
                                  if(ptr[j]->at > ptr[j+1]->at){
                                         temp1 = ptr[j];
                                         ptr[j] = ptr[j+1];
                                         ptr[j+1] = temp1;
                                  }
                              }
                          }
                          int current_time =0 ;
                          int completed =0;
                          while(completed != n){
                              int id_found = -1;
                              int min = 10000000;
                              for(int i=0;i < n;i++){
                                  if(ptr[i]->at <= current_time && is_completed[i]== 0){
                                      if(ptr[i]->bt_rem < min){
                                          min = ptr[i]->bt_rem;
                                          id_found = i;
                                      }
                                      if(ptr[i]->bt_rem == min){
                                          if(ptr[i]->at < ptr[id_found]->at){
                                              min = ptr[i]->bt_rem;
                                              id_found = i;
                                          }
                                      }
                                  }
                              }
                              if(id_found != -1){
                                  if(ptr[id_found]->bt_rem == ptr[id_found]->bt){
                                      ptr[id_found]->st = current_time;
                                  } 
                                  ptr[id_found]->bt_rem = ptr[id_found]->bt_rem-1;
                                  current_time++;
                                  check[k]=current_time;
                                  k++;
                                  checkprocess[l]=id_found;
                                  l++;
                      
                                  if(ptr[id_found]->bt_rem == 0){
                                      ptr[id_found]->ct = current_time;
                                      ptr[id_found]->tat = ptr[id_found]->ct - ptr[id_found]->at;
                                      ptr[id_found]->wt = ptr[id_found]->tat - ptr[id_found]->bt;
                      
                                      totalTAT += ptr[id_found]->tat;
                                      totalWT += ptr[id_found]->wt;
                      
                                      is_completed[id_found] = 1;
                                      completed++;
                                  }
                              }
                              else{
                                  current_time++;
                              }
                          }
                          float avg_tat = (float)totalTAT/n;
                          float avg_wt = (float)totalWT/n;
                          struct os *temp2;
                          for(i=0;i < n;i++){
                              for(int j=0;j < n-1;j++){
                                  if(ptr[j]->pid > ptr[j+1]->pid){
                                         temp2 = ptr[j];
                                         ptr[j] = ptr[j+1];
                                         ptr[j+1] = temp2;
                                  }
                              }
                          }
                              printf("\nprocess\t   Arrivaltime\t    Bursttime\tCompletionTime\tTurnAroundTime
                              \t  WaitingTime\n");
                          for(i=0;i < n;i++){
                              printf("\nP%d\t\t%d\t\t%d\t\t%d  \t\t%d  \t\t %d", ptr[i]->pid,ptr[i]->at,ptr[i]->bt,
                               ptr[i]->ct, ptr[i]->tat, ptr[i]->wt);
                          }
                          printf("\n\nAverage TurnAroundTime : %.2f",avg_tat);
                          printf("\nAverage WaitingTime : %.2f",avg_wt);
                          gantt_chart(n);
                          return 0;
                      }
                  </code></pre>
                  <br>
                  <br>
                </p>
              </div>
            </div>

          </div>
        </div>
      </div>
    </section>
    <section class="u-clearfix u-section-2" id="sec-d567">
      <div class="u-clearfix u-sheet u-sheet-1"></div>
    </section>
    

  </body>
</html>