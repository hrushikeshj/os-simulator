<!DOCTYPE html>
<html style="font-size: 16px;">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="​Important Leadership Skills">
    <meta name="description" content="">
    <meta name="page_type" content="np-template-header-footer-from-plugin">
    <title>LJF</title>
    <link rel="stylesheet" href="nicepage.css" media="screen">
<link rel="stylesheet" href="Simulation.css" media="screen">
    <script class="u-script" type="text/javascript" src="jquery.js" defer=""></script>
    <script class="u-script" type="text/javascript" src="nicepage.js" defer=""></script>
    <meta name="generator" content="Nicepage 4.9.5, nicepage.com">
    <link id="u-theme-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i|Open+Sans:300,300i,400,400i,500,500i,600,600i,700,700i,800,800i">
    <link id="u-page-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i">
    <style>
      body {
        background-image: url('images/bg3.png');
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: 100% 100%;
      }
      </style>
    
    
    <script type="application/ld+json">{
		"@context": "http://schema.org",
		"@type": "Organization",
		"name": ""
}</script>
    <meta name="theme-color" content="#478ac9">
    <meta property="og:title" content="Simulation">
    <meta property="og:type" content="website">
  </head>
  <body data-home-page="Simulation.html" data-home-page-title="Simulation" class="u-body u-xl-mode"><header class="u-clearfix u-header u-header" id="sec-3af7" style="background-color: #5980a1;"><div class="u-clearfix u-sheet u-sheet-1">
        <nav class="u-menu u-menu-dropdown u-offcanvas u-menu-1">
          <div class="menu-collapse" style="font-size: 1rem; letter-spacing: 0px;">
            <a class="u-button-style u-custom-left-right-menu-spacing u-custom-padding-bottom u-custom-top-bottom-menu-spacing u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="#">
              <svg class="u-svg-link" viewBox="0 0 24 24"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#menu-hamburger"></use></svg>
              <svg class="u-svg-content" version="1.1" id="menu-hamburger" viewBox="0 0 16 16" x="0px" y="0px" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><g><rect y="1" width="16" height="2"></rect><rect y="7" width="16" height="2"></rect><rect y="13" width="16" height="2"></rect>
</g></svg>
            </a>
          </div>
          <div class="u-custom-menu u-nav-container">
            <ul class="u-nav u-unstyled u-nav-1"><li class="u-nav-item"><a class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="../../index.html" style="padding: 10px 20px;">Home</a>
</li></ul>
          </div>
          <div class="u-custom-menu u-nav-container-collapse">
            <div class="u-black u-container-style u-inner-container-layout u-opacity u-opacity-95 u-sidenav">
              <div class="u-inner-container-layout u-sidenav-overflow">
                <div class="u-menu-close"></div>
                <ul class="u-align-center u-nav u-popupmenu-items u-unstyled u-nav-2"><li class="u-nav-item"><a class="u-button-style u-nav-link" href="../../index.html">Home</a>
</li></ul>
              </div>
            </div>
            <div class="u-black u-menu-overlay u-opacity u-opacity-70"></div>
          </div>
        </nav>
      </div></header>
    <section class="u-align-left u-clearfix u-grey-5 u-section-1" id="carousel_a616">
      <div class="u-clearfix u-sheet u-sheet-1">
        <h2 class="u-custom-font u-font-montserrat u-text u-text-default u-text-1">Longest Job First Algorithm (LJF)</h2>
        <div class="u-expanded-width u-tab-links-align-left u-tabs u-tabs-1">
          <ul class="u-spacing-15 u-tab-list u-unstyled" role="tablist">
            <li class="u-tab-item" role="presentation">
              <a class="active u-active-palette-1-base u-button-style u-tab-link u-text-active-white u-text-body-color u-text-hover-grey-75 u-tab-link-1" id="link-tab-0da5" href="#tab-0da5" role="tab" aria-controls="tab-0da5" aria-selected="true">Theory</a>
            </li>
            <li class="u-tab-item" role="presentation" style="font-size: 20px;padding-top: 9px;">
              <a  href="ljf.html">Simulation</a>
            </li>
          </ul>
          <div class="u-tab-content">
            <div class="u-align-left u-container-style u-tab-active u-tab-pane u-white u-tab-pane-1" id="tab-0da5" role="tabpanel" aria-labelledby="link-tab-0da5">
              <div class="u-container-layout u-container-layout-1">
                <p class="u-text u-text-2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ​​Longest Job First&nbsp;(LJF)&nbsp;scheduling comes under the category of&nbsp;the non-preemptive scheduling&nbsp;algorithm. This algorithm mainly keeps the track of Burst time of all processes that are available at the arrival time itself and then it will assign the processor to the process having the longest burst time. In this algorithm, once a process starts its execution then it cannot be interrupted in between its processing. Any other process can be&nbsp;executed only after&nbsp;the assigned process has completed its processing and has been terminated.<br>
                  <br> This scheduling is similar to&nbsp;the SJF&nbsp;scheduling algorithm. But, in this scheduling algorithm, the priority is given to the process having the longest burst time.<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; ​Although this scheduling algorithm is not considered to be an efficient way of scheduling the processes&nbsp; because there are many drawbacks of it:<br>&nbsp; &nbsp;​&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1)&nbsp; The first one is the Convoy effect is displayed by it<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2) The second one is this algorithm has a very large average turn-around time and average&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waiting time. Due to these two, the effectiveness of the system decreases and processing&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;becomes slow.<br>
                  <br>&nbsp; In a situation if two processes having the same burst time then the tie is broken using FCFS i.e., the process that arrived first is processed first.<br>
                  <br>Let us take a look at the Procedure used in LJF scheduling:<br>
                  <br>&nbsp;1) In the First step, the algorithm sort the processes according to the increasing order of their Arrival Time.<br>&nbsp;<br>&nbsp;2) In the second step, it will choose the process having the highest Burst Time among all the processes that have arrived till that time.<br>&nbsp;<br>&nbsp;3) After that, it will process it for its given burst time. The LJF also checks if any other process arrives until this process completes its execution.<br>
                  <br>4) last but not least it will Repeat all the above steps until all the processes are executed.<br>
                  <br>Now its time to take a look at the example of LJF Scheduling:&nbsp; &nbsp; &nbsp;&nbsp;<br>
                  <br>
                  <br>
                  <span style="font-weight: 700; font-size: 1.5rem;">Example :&nbsp;</span>
                  <br> In the below example, four processes P1, P2, P3, P4 are given along with their Burst time and arrival time.<br>
                  <br>
                </p>
                <img class="u-image u-image-default u-image-1" src="images/ljf_exp.png" alt="" data-image-width="1616" data-image-height="718">
                <p class="u-text u-text-3">
                  <span style="font-weight: 700; font-size: 1.375rem;">Explanation :&nbsp;</span>
                  <br>
                  <br>Let us understand the working of LJF in the Gantt chart given above<br>
                  <br>1) ​​At t = 0, there is one process that is available having 2 units of burst time. So, select P1 and execute it for 2 ms.<br>2) ​​At t = 2 i.e. after P1 gets executed, The Available Processes are P2, P3. As you can see the burst time of P3 is more than P2. So, select P3 and execute it for 5ms.<br>3) ​​At t = 7 i.e. after the execution of P3, the Available Processes are P2, P4. As you can see the burst time of P4 is more than P2. So, select P4 and execute it for 7ms.<br>4) ​Finally, after the completion of P4 execute the process P2 for 3 ms.<br>
                  <br>You can determine the completion time easily with the help of the Gantt chart. Let us calculate the waiting time and turnaround time.<br>
                  <br>
                  <br>
                  <br>
                  <br>
                  <br>
                </p>
                <img class="u-image u-image-default u-image-2" src="images/ljf_exp11.png" alt="" data-image-width="1616" data-image-height="896">
                <p class="u-text u-text-4"> Average waiting time is calculated by adding the waiting time of all processes and then dividing them by no. of processes.<br>
                  <br>average waiting time = waiting for the time of all processes/ no.of processes<br>
                  <br>average waiting time=0+13+0+4/4=17/4=4.25ms<br>
                  <br>
                  <span style="font-weight: 700; font-size: 1.375rem;">Disadvantages of LJF Scheduling :&nbsp;</span>
                  <br>&nbsp;<br>&nbsp;1) This algorithm leads to the reduction of processing speed due to which there is a reduction in the efficiency and utilization of the system.<br>&nbsp;<br>&nbsp;2) Due to this algorithm, for a given set of processes, the average waiting time and average turn-around time increase.<br>
                  <br>&nbsp;3) This algorithm leads to the convoy effect.<br>
                  <br>&nbsp;4) With this algorithm, there is a possibility that a short process may never get executed and the system keeps on executing the long processes.<br>
                  <br>
                  <span style="font-weight: 700;">
                    <span style="font-size: 1.375rem;"> C program to simulate LJF algorithm</span>
                  </span>
                  <br>&nbsp;<br>
                  <pre><code class="language-java graf graf--code">
                    #include  < stdio.h >
                      #include  < stdlib.h >
                      
                      struct os{
                          int pid;
                          float at;
                          float bt;
                          float ct;
                          float tat;
                          float wt;
                          float st;
                          int new_id;
                       
                      }*ptr[100];
                      
                      void gantt_chart( int n){
                          int i;
                          
                          printf("\n\nGannt Chart:\n");
                          for(i=0;i< n; i++){
                              printf("----------------");
                          }
                          printf("\n");
                          int check=0;
                          for(int check=0;check < n;check++){
                              for(int i=0;i < n;i++){
                                  if(ptr[i]->new_id == check){
                                  printf("|\tP%d\t",ptr[i]->pid);
                                  break;
                                }
                              }
                          }
                          printf("|\n");
                          for(i=0; i< n; i++){
                              printf("----------------");
                          }
                          printf("\n");
                          
                          struct os *temp;
                          for(i=0;i < n;i++){
                              for(int j=0;j < n-1;j++){
                                  if(ptr[j]->new_id > ptr[j+1]->new_id){
                                         temp = ptr[j];
                                         ptr[j] = ptr[j+1];
                                         ptr[j+1] = temp;
                                  }
                              }
                          }
                          printf("%.1f      \t",ptr[0]->at);
                          
                          for(i=0;i < n;i++){
                                printf("%.1f      \t",ptr[i]->ct);        
                          }
                      }
                      
                      int main(){
                          int n;
                          printf("Enter how many processes : ");
                          scanf("%d", &n);
                          float avgTAT=0, avgWT=0,avgRT=0;
                          int i, time=0.0;
                          int is_completed[100];
                          for(int i=0;i < n;i++){
                              is_completed[i]=0;
                          }
                      
                          //n ptr[];
                          printf("-----LJF----\n");
                          for(i=0;i < n;i++){
                             ptr[i] = (struct os*)malloc(sizeof(struct os));
                              printf("Enter arrivaltime of process %d :",i+1);
                              scanf("%f", &ptr[i]->at);
                              printf("Enter bursttime of process %d :",i+1);
                              scanf("%f", &ptr[i]->bt);
                              ptr[i]->pid = i+1;
                          }
                          struct os *temp1;
                          for(i=0;i < n;i++){
                              for(int j=0;j < n-1;j++){
                                  if(ptr[j]->at > ptr[j+1]->at){
                                         temp1 = ptr[j];
                                         ptr[j] = ptr[j+1];
                                         ptr[j+1] = temp1;
                                  }
                              }
                          }
                          int current_time =0 ;
                          int completed =0;
                          int k=0;
                      
                          while(completed !=n){
                              int id_found= -1;
                              int max = 0;
                              //to calculate highest burst time
                              for(int i=0;i < n;i++){
                                  if(ptr[i]->at <= current_time && is_completed[i]== 0){
                                      if(ptr[i]->bt > max){
                                          max = ptr[i]->bt;
                                          id_found= i;
                                      }
                                      if(ptr[i]->bt == max){
                                          if(ptr[i]->at < ptr[id_found]->at){
                                              max = ptr[i]->bt;
                                              id_found= i;
                                          }
                                      }
                                  }
                              }
                              if(id_found!= -1){
                                  ptr[id_found]->st = current_time;
                                  ptr[id_found]->ct = ptr[id_found]->st + ptr[id_found]->bt;
                                  ptr[id_found]->tat = ptr[id_found]->ct - ptr[id_found]->at;
                                  ptr[id_found]->wt = ptr[id_found]->tat - ptr[id_found]->bt;
                                  ptr[id_found]->new_id = k;
                                  k++;
                      
                                  avgTAT += ptr[id_found]->tat;
                                  avgWT += ptr[id_found]->wt;
                      
                                  is_completed[id_found]= 1;
                                  completed++;
                                  current_time = ptr[id_found]->ct;
                              }
                              else{
                                  current_time++;
                              }
                          }
                      
                           printf("\nn\t   Arrivaltime\t    Bursttime\tCompletionTime\tTurnAroundTime\t  WaitingTime\n");
                          for(i=0;i < n;i++){
                              printf("\nP%d\t\t%.1f\t\t%.1f\t\t%.1f  \t\t%.1f  \t\t %.1f", ptr[i]->pid,ptr[i]->at,ptr[i]->bt, ptr[i]->ct, ptr[i]->tat, ptr[i]->wt);
                          }
                          printf("\n\nAverage TurnAroundTime : %.2f",avgTAT/n);
                          printf("\nAverage WaitingTime : %.2f",avgWT/n);
                      
                          gantt_chart(n);
                      
                          return 0;
                      }
                  </code></pre>
                  <br>
                  <br>
                
                </p>
              </div>
            </div>

          </div>
        </div>
      </div>
    </section>
    <section class="u-clearfix u-section-2" id="sec-d567">
      <div class="u-clearfix u-sheet u-sheet-1"></div>
    </section>
    
    

  </body>
</html>