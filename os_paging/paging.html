<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    
<style>
p {
    font-size: 20px;
   
}

body {
    margin-top: 75px;
  margin-bottom: 75px;
  margin-right: 100px;
  margin-left: 100px;
  border-style: groove;
  padding-top: 50px;
  padding-right: 30px;
  padding-bottom: 50px;
  padding-left: 30px;

}
</style>

<body>

    <br>
<center>
    <h2><u>PAGING</u></h2></center>
    <p>
        Paging is a storage mechanism used to retrieve processes from the secondary storage into the main memory in the form of pages. <br>
The main idea behind the paging is to divide each process in the form of pages. The main memory will also be divided in the form of frames. <br>
 One page of the process is to be stored in one of the frames of the memory. The pages can be stored at the different locations of the memory but the priority is always to find the contiguous frames or holes. <br>
 Pages of the process are brought into the main memory only when they are required otherwise, they reside in the secondary storage. <br>
    </p>
    <h3>PAGE TABLE</h3>
    <p>
        Page Table is a data structure used by the virtual memory system to store the mapping between logical addresses and physical addresses. <br>
        Logical addresses are generated by the CPU for the pages of the processes therefore they are generally used by the processes. <br>
        Physical addresses are the actual frame address of the memory. They are generally used by the hardware or more specifically by RAM subsystems. <br>

       </p>
       <center>
        <img src="Page table.jpg" alt="Pagetable" width="700" height="333">
        </center>
        <p>
            The CPU always accesses the processes through their logical addresses. However, the main memory recognizes physical address only.<br>
            In this situation, a unit named as Memory Management Unit comes into the picture. It converts the page number of the logical address to the frame number of the physical address. The offset remains same in both the addresses.<br>
            To perform this task, Memory Management unit needs a special kind of mapping which is done by page table. The page table stores all the Frame numbers corresponding to the page numbers of the page table.<br>
            In other words, the page table maps the page number to its actual location (frame number) in the memory.<br>
            The page table is stored in Main memory. Support by hardware is provided by using a special, small, lookup hardware cache, called a translation look-aside buffer (TLB). <br>
            In the image given below shows, how the required word of the frame is accessed with the help of offset. <br></p>
            <center>
                <img src="frameimage.jpg" alt="Main Memory" width="600" height="333">
                </center><br>
    </head>
    <body>
                
                <center>
               <h1> MAPPING FROM PAGE TABLE TO MAIN MEMORY </h1></center>
               
               <p>In operating systems, there is always a requirement of mapping from logical address to the physical address. However, this process involves various steps which are defined as follows.<br></p>
                
                    <h2>
                        1. Generation of logical address 
                    </h2>
                
                <p>  CPU generates logical address for each page of the process. This contains two parts: page number and offset. <br>
                </p>
                    <h2>
                        2. Scaling
                    </h2>
               
                <p>To determine the actual page number of the process, CPU stores the page table base in a special register. Each time the address is generated, the value of the page table base is added to the page number to get the actual location of the page entry in the table. This process is called scaling. <br>
        </p>
        
            <h2>3. Generation of physical Address </h2>
            <p>
                The frame number of the desired page is determined by its entry in the page table. A physical address is generated which also contains two parts: frame number and offset. The Offset will be similar to the offset of the logical address therefore it will be copied from the logical address. <br>
            </p>
            <h2>
                4. Getting Actual Frame Number 
            </h2>
       <p>The frame number and the offset from the physical address is mapped to the main memory in order to get the actual word address. <br></p>
       <center>
        <img src="Address_translation.png" alt="Address translation" width="600" height="333">
        </center><br> 
        <h1> STRUCTURING OF PAGE TABLE</h1>
        <p>
            Most commonly used techniques for structuring the page table are- 
        </p>
        <h2>
            i) Hierarchical Paging:
        </h2>
        <p>
            It is also called as multilevel paging. Multilevel Paging is a paging scheme which consist of two or more levels of page tables in a hierarchical manner. It is also known as hierarchical paging. The entries of the level 1 page table are pointers to a level 2page table and entries of the level 2 page tables are pointers to a level 3 page table and so on. <br>
        </p>
        <center>
            <img src="multilevel.png" alt="Multilevel Paging" width="600" height="333">
            </center><br>
            <h2>
                ii) Hashed Page Table:
            </h2>
            <p>
                In hashed page tables, the virtual page number in the virtual address is hashed into the hash table. They are used to handle address spaces higher than 32 bits. Each entry in the hash table has a linked list of elements
                 hashed to the same location (to avoid collisions – as we can get the same value of a hash function for different page numbers). The hash value is the virtual page number. The Virtual Page Number is all the bits that are not a part of the page offset. <br>
            </p>
            <P>
                For each element in the hash table, there are three fields – 
                 <br>
               1. Virtual Page Number (which is the hash value). 
                         <br>
               2. Value of the mapped page frame. 
                         <br>
                3.A pointer to the next element in the linked list. 
            </P>
            <center>
                <img src="hashed paging.jpg" alt="Hashed Paging" width="700" height="333">
                </center><br>
            <h2>
                iii) Inverted Page Table:
            </h2>
            <p>
                Inverted Page Table structure consists of one-page table entry for every frame of the main memory. So, the number of page table entries in the Inverted Page Table 
                reduces to the number of frames in physical memory and a single page table is used to represent the paging information of all the processes.  This technique is called as inverted paging as the indexing is done with respect to the frame number instead of the logical page number. Each entry in the page table contains the following fields. 
<br>
            </p>
            <p>
                A)Page number<br>
                B)process id<br>
                C)process id<br>
                D)Chained pointer <br>
            </p>
            <center>
                <img src="Invertedpagetable.png" alt="Inverted Paging" width="600" height="333">
                </center><br>



</head>
</body>
</html>