<!DOCTYPE html>
<html style="font-size: 16px;">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="">
    <meta name="description" content="">
    <meta name="page_type" content="np-template-header-footer-from-plugin">
    <title>Bankers Algorithm</title>
    <link rel="stylesheet" href="nicepage.css" media="screen">
    <link rel="stylesheet" href="Home.css" media="screen">
    <script class="u-script" type="text/javascript" src="jquery.js" defer=""></script>
    <script class="u-script" type="text/javascript" src="nicepage.js" defer=""></script>
    <meta name="generator" content="Nicepage 4.9.5, nicepage.com">
    <link id="u-theme-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i|Open+Sans:300,300i,400,400i,500,500i,600,600i,700,700i,800,800i">
    <link id="u-page-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i">
    <style>
      body {
        background-image: url('../Bankers_algo/images/bg3.png');
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: 100% 100%;
      }
      </style>
    
    
    <script type="application/ld+json">{
		"@context": "http://schema.org",
		"@type": "Organization",
		"name": ""
}</script>
    <meta name="theme-color" content="#478ac9">
    <meta property="og:title" content="Home">
    <meta property="og:type" content="website">
  </head>
  <body data-home-page="Home.html" data-home-page-title="Home" class="u-body u-xl-mode"><header class="u-clearfix u-header u-header" id="sec-3af7"><div class="u-clearfix u-sheet u-sheet-1">
        <nav class="u-menu u-menu-dropdown u-offcanvas u-menu-1">
          <div class="menu-collapse" style="font-size: 1rem; letter-spacing: 0px;">
            <a class="u-button-style u-custom-left-right-menu-spacing u-custom-padding-bottom u-custom-top-bottom-menu-spacing u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="#">
              <svg class="u-svg-link" viewBox="0 0 24 24"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#menu-hamburger"></use></svg>
              <svg class="u-svg-content" version="1.1" id="menu-hamburger" viewBox="0 0 16 16" x="0px" y="0px" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><g><rect y="1" width="16" height="2"></rect><rect y="7" width="16" height="2"></rect><rect y="13" width="16" height="2"></rect>
</g></svg>
            </a>
          </div>
          <div class="u-custom-menu u-nav-container">
            <ul class="u-nav u-unstyled u-nav-1"><li class="u-nav-item"><a class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="../index.html" style="padding: 10px 20px;">Home</a>
</li><li class="u-nav-item"><a class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="bankers_theory.html" style="padding: 10px 20px;">Theory</a>
</li><li class="u-nav-item"><a class="u-button-style u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="bankers_simulation.html" style="padding: 10px 20px;">Simulation</a>
</li></ul>
          </div>
          <div class="u-custom-menu u-nav-container-collapse">
            <div class="u-black u-container-style u-inner-container-layout u-opacity u-opacity-95 u-sidenav">
              <div class="u-inner-container-layout u-sidenav-overflow">
                <div class="u-menu-close"></div>
                <ul class="u-align-center u-nav u-popupmenu-items u-unstyled u-nav-2"><li class="u-nav-item"><a class="u-button-style u-nav-link" href="../index.html">Home</a>
</li><li class="u-nav-item"><a class="u-button-style u-nav-link" href="bankers_theory.html">Theory</a>
</li><li class="u-nav-item"><a class="u-button-style u-nav-link" href="bankers_simulation.html">Simulation</a>
</li></ul>
              </div>
            </div>
            <div class="u-black u-menu-overlay u-opacity u-opacity-70"></div>
          </div>
        </nav>
      </div></header>
    <section class="u-align-left u-clearfix u-section-1" id="carousel_1022" >
      <div class="u-clearfix u-sheet u-valign-bottom-md u-valign-bottom-sm u-valign-bottom-xs u-sheet-1">
        <blockquote class="u-border-20 u-border-palette-4-base u-custom-font u-font-montserrat u-text u-text-default u-text-1">Bankers Algorithm<br>
        </blockquote>
        <p class="u-custom-font u-font-montserrat u-text u-text-2" style="text-align: justify;"> Bankerâ€™s Algorithm is a<b>&nbsp;deadlock avoidance algorithm</b>. It is also used for deadlock detection. This algorithm tells that if any system can go into a deadlock or not by analyzing the currently allocated resources and the resources required by it in the future. 
          <br>Deadlocks are a set of blocked processes each holding a resource
          and waiting to acquire a resource held by another process.<br>In General, a process must request a resource before using it and it
          must release the resource after using it. And any process can
          request as many resources as it requires in order to complete its
          designated task. And there is a condition that the number of
          resources requested may not exceed the total number of resources
          available in the system.<br>Basically in the Normal mode of Operation utilization of resources
          by a process is in the following sequence:<br>
                    <span style="font-weight: 700;"> 1</span>
                    <span style="font-weight: 700;">. Request</span>: Firstly, the process requests the resource. In a case, if
          the request cannot be granted immediately(e.g: resource is
          being used by any other process), then the requesting process
          must wait until it can acquire the resource.&nbsp;<br><b>2</b>. <span style="font-weight: 700;">Use:</span> The Process can operate on the resource ( e.g: if the
          resource is a printer then in that case process can print on the
          printer).&nbsp;<br>
                    <span style="font-weight: 700;">3</span>. <span style="font-weight: 700;">Release</span>: The Process releases the resource.<br>The deadlock situation can only arise if all the following four
          conditions hold simultaneously:<br>
                    <span style="font-weight: 700;"> 1.Mutual Exclusion :<br>
                    </span>According to this condition, atleast one resource should be nonshareable (non-shareable resources are those that can be used by
          one process at a time.)&nbsp;<br>
                    <span style="font-weight: 700;">2. Hold and wait&nbsp;<span style="font-weight: 400;">
                        <span style="font-weight: 700;">:</span>
                      </span>
                    </span>&nbsp;According to this condition, A process is holding atleast one
          resource and is waiting for additional resources.&nbsp;<br>
                    <span style="font-weight: 700;"> 3. NO preemption</span>&nbsp;<span style="font-weight: 700;"> :</span> Resources cannot be taken from the process because resources can
          be released only voluntarily by the process holding them.&nbsp;<br>
                    <span style="font-weight: 700;">4. Circular wait</span>&nbsp;<span style="font-weight: 700;"> :</span> In this condition, the set of processes are waiting for each other in
          the circular form.&nbsp;<br>
                    <br>The above four conditions are not completely independent as the
          circular wait condition implies the hold and wait condition. We
          emphasize on the fact that all four conditions must hold for a
          deadlock.<br>&nbsp;Deadlock conditions can be avoided with the help of a number of
          methods. Let us take a look at some of the methods.<br>
                    <span style="font-weight: 700;">Methods For Handling Deadlocks :&nbsp;<br>1. Ignoring the Deadlock&nbsp;
                    </span>
                    <br>According to this method, it is assumed that deadlock would never
          occur.This approach is used by many operating systems where they
          assume that deadlock will never occur which means operating
          systems simply ignores the deadlock. This approach can be
          beneficial for those systems that are only used for browsing and for
          normal tasks. Thus ignoring the deadlock method can be useful in
          many cases but it is not perfect in order to remove the deadlock
          from the operating system.&nbsp;<br>
                    <br>
                    <span style="font-weight: 700;">2.Deadlock Prevention&nbsp;</span>
                    <br>As we have discussed in the above section, that all four conditions:
          Mutual Exclusion, Hold and Wait, No preemption, and circular wait if
          held by a system then causes deadlock to occur. The main aim of
          the deadlock prevention method is to violate any one condition
          among the four; because if any of one condition is violated then the
          problem of deadlock will never occur. As the idea behind this
          method is simple but the difficulty can occur during the physical
          implementation of this method in the system.&nbsp;<br>
                    <br>
                    <span style="font-weight: 700;">3.Avoiding the Deadlock&nbsp;</span>
                    <br>This method is used by the operating system in order to check
          whether the system is in a safe state or in an unsafe state. This
          method checks every step performed by the operating system. Any
          process continues its execution until the system is in a safe state.
          Once the system enters into an unsafe state, the operating system
          has to take a step back.Basically, with the help of this method, the operating system keeps
          an eye on each allocation, and make sure that allocation does not
          cause any deadlock in the system.<br>
                    <br>
                    <span style="font-weight: 700;">4.Deadlock detection and recovery</span>
                    <br>With this method, the deadlock is detected first by using some
          algorithms of the resource-allocation graph. This graph is mainly
          used to represent the allocations of various resources to different
          processes. After the detection of deadlock, a number of methods
          can be used in order to recover from that deadlock.&nbsp;<br>One way is preemption by the help of which a resource held by
          one process is provided to another process.
          The second way is to roll back, as the operating system keeps a
          record of the process state and it can easily make a process roll
          back to its previous state due to which deadlock situation can be
          easily eliminate.&nbsp;<br>The third way to overcome the deadlock situation is by killing one
          or more processes<br>
                    <br>
                    <span style="font-weight: 700; font-size: 1.4375rem;">DEADLOCK AVOIDANCE :&nbsp;</span>
                    <br>The deadlock Avoidance method is used by the operating system in order to check whether
          the system is in a safe state or in an unsafe state and in order to avoid the deadlocks, the
          process must need to tell the operating system about the maximum number of resources a
          process can request in order to complete its execution.<br>
                    <br>
                    <span style="font-weight: 700;">How does Deadlock Avoidance work?</span>
                    <br>&nbsp;In this method, the request for any resource will be granted only if the resulting state
          of the system doesn't cause any deadlock in the system. This method checks every
          step performed by the operating system. Any process continues its execution until
          the system is in a safe state. Once the system enters into an unsafe state, the
          operating system has to take a step back.
          With the help of a deadlock-avoidance algorithm, you can dynamically assess the
          resource-allocation state so that there can never be a circular-wait situation.
          According to the simplest and useful approach, any process should declare the
          maximum number of resources of each type it will need. The algorithms of deadlock
          avoidance mainly examine the resource allocations so that there can never be an
          occurrence of circular wait conditions.
          Deadlock avoidance can mainly be done with the help of Banker's Algorithm.<br>
                    <br>
                    <span style="font-weight: 700;">What is Bankerâ€™s Algorithm?</span>
                    <br>Bankerâ€™s Algorithm is used majorly in the banking system to avoid deadlock. It
          helps you to identify whether a loan will be given or not.<br>
        </p>
        <p style="text-align: justify;font-family: 'Montserrat';font-size: 20px;">There are various data structures which are used to implement this algorithm. So, let's learn about these first.
        </p>
        <p class="u-text u-text-3">
          <span style="font-weight: 700; font-size: 1.625rem;">Data Structures used to implement Bankerâ€™s Algorithm :&nbsp;</span>
          <br>
          <br>
          <span style="font-size: 1.25rem;"><b>Available:</b>&nbsp;It is a 1-D array that tells the number of each resource type (instance of resource type) currently&nbsp;
          </span>
          <br>
          <span style="font-size: 1.25rem;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; available.&nbsp;<b><i>Example:</i></b>&nbsp;Available[R1]= A, means that there are A instances of R1 resources are currently&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; available.<br>
            <br><b>&nbsp; &nbsp; Max&nbsp; &nbsp; &nbsp;:</b>&nbsp;It is a 2-D array that tells the maximum number of each resource type required by a process for&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;successful&nbsp; &nbsp;execution.&nbsp;<b><i>Example:</i></b>&nbsp;Max[P1][R1] = A, specifies that the process P1 needs a maximum&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of&nbsp;<b>A</b>&nbsp;instances&nbsp; of resource R1 for complete execution.<br>
            <br><b>Allocation :&nbsp;</b>It is a 2-D array that tells the number of types of each resource type that has been allocated to the&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;process.&nbsp;<b>Example:</b>&nbsp;Allocation[P1][R1] = A, means that<b>&nbsp;A</b>&nbsp;instances of resource type R1 have been allocated to&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the process P1.<br>
            <br><b>&nbsp; &nbsp; &nbsp;Need&nbsp; &nbsp; :&nbsp;</b>It is a 2-D array that tells the number of remaining instances of each resource type required for&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; execution.<b>&nbsp;Example:&nbsp;</b>Need[P1][R1]= A tells that&nbsp;<b>A</b>&nbsp;instances of R1 resource type are required for the execution&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of process P1.
          </span>
          <br>
          <br>
          <span style="font-size: 1.25rem;">
            <span style="font-weight: 700;">&nbsp; &nbsp; &nbsp; NOTE :&nbsp; &nbsp;</span>Need[i][j]= Max[i][j] - Allocation[i][j], where i corresponds any process P(i) and j corresponds to any resouce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type R(j)
          </span>
          <br>
          <br><b style="color: rgba(0, 0, 0, 0);">The Bankers Algorithm consists of the following two algorithms</b>
          <br>
          <span style="font-size: 1.5rem;"><b>The Bankers Algorithm consists of the following two algorithms :&nbsp;</b>
            <br>
          </span>
          <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="font-size: 1.25rem;">1. Request-Resource Algorithm<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2. Safety Algorithm
          </span>
          <br>
          <br>&nbsp;<span style="font-size: 1.375rem;">
            <span style="font-weight: 700;">Resource- Request Algorithm :</span>
            <br>
          </span>
          <br>
          <span style="font-size: 1.25rem;">Whenever a process makes a request of the resources then this algorithm checks that if the resource can be allocated or not..</span>
          <br>
          <span style="font-size: 1.25rem;"><b>It includes three steps:</b>
          </span>
          <br>
          <br>
          <span style="font-size: 1.25rem;">
            <span style="font-size: 1rem;">
              <span style="font-size: 1.25rem;"> 1</span>
            </span>. The algorithm checks that if the request made is valid or not. A request is valid if the number of requested resources of each resource type is less than the<b>&nbsp;Need(</b>which was declared previously by the process<b>).&nbsp;</b>If it is a valid request then step 2 is executed else aborted.<br>
            <br>2. Here, the algorithm checks that if the number of requested instances of each resource is less than the available resources. If not then the process has to wait until sufficient resources are available else go to step 3.<br>
            <br>3. Now, the algorithm assumes that the resources have been allocated and modifies the data structure accordingly.
          </span>
          <br><pre><code class="language-java graf graf--code">Available = Available - Request(i)</code></pre>
          <br>
          <span style="font-size: 1.25rem;"> After the allocation of resources, the new state formed may or may not be a safe state. So, the&nbsp;<b>safety algorithm</b>&nbsp;is applied to check whether the resulting state is a safe state or not.
          </span>
          <br>
          <br>
          <span style="font-size: 1.25rem;"><b>Safe state:</b>&nbsp;A safe state is a state in which all the processes can be executed in some arbitrary order with the available&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;resources such that no deadlock occurs.<br>
          </span>
          <br>
          <span style="font-size: 1.25rem;">1. If it is a safe state, then the requested resources are allocated to the process in actual.<br>2. If the resulting state is an unsafe state then it rollbacks to the previous state and the process is asked to wait longer.<br>
            <br><b>This algorithm involves the following four steps:</b>
            <br>
            <br>1. Suppose currently all the processes are to be executed. Define two data structures as work and finish as vectors of length m(where m is the length of<b>&nbsp;Available</b>&nbsp;vector)and n(is the&nbsp;<b>number of processes</b>&nbsp;to be executed).<br><pre><code class="language-java graf graf--code">Work = Available <br>Finish[i] =false for i = 0, 1, â€¦ , nâ€Šâ€”â€Š1.</code></pre><br>
            2. This algorithm will look for a process that has<b>&nbsp;Need</b>&nbsp;value less than or equal to the&nbsp;<b>Work</b>. So, in this step, we will find an index i such that<br><br><pre><code class="language-java graf graf--code">Finish[i] ==false && Need[i] <= Work  </code></pre><br>
            If no such â€˜iâ€™ is present then go to step 4 else to step 3.<br>3. The process '<b>i'&nbsp;</b>selected in the above step runs and finishes its execution. Also, the resources allocated to it gets free. The resources which get free are added to the Work and Finish(i) of the process is set as true. The following operations are performed:<br><br><pre><code class="language-java graf graf--code">Work = Work + Allocation <br> Finish[i] = true </code></pre><br>
            After performing the 3rd step go to step 2.<br>
            <br>4. If all the processes are executed in some sequence then it is said to be a safe state. Or, we can say that if<br><br><pre><code class="language-java graf graf--code">Finish[i]==true for all i, <code></pre>
            <br>then the system is said to be in a&nbsp;<b>safe state</b>.<br>
          </span>
          <br>
          <h2>C Program to simulate Bankers Algorithm </h2>
          <br>
          <pre><code class="language-java graf graf--code">
            #include< stdio.h>
              int main() {
                int k=0,d=0,t=0,i,j,pno,rz, count=0;
                printf("\n Enter the number of resources : ");
                scanf("%d", &rz);
                  int avail[rz],ins[rz],totalallocated[rz];
                  for(int i=0;i < rz;i++){
                      totalallocated[i]=0;
                  }
                printf("\n enter the total instances of each resources\n");
                for (i=0;i < rz;i++) {
                  avail[i]=0;
                  printf("%c= ",(i+97));
                  scanf("%d",&ins[i]);
                }
                printf("\n Enter the number of processes : ");
                scanf("%d", &pno);
                  int allocated[pno][rz],need[pno][rz],MAX[pno][rz],P[pno],output[pno];
                printf("\n Enter the allocation matrix \n     ");
                for (i=0;i < rz;i++)
                printf(" %c",(i+97));
                printf("\n");
                for (i=0;i < pno;i++) {
                  P[i]=i;
                  printf("P[%d]  ",P[i]);
                  for (j=0;j< rz;j++) {
                    scanf("%d",&allocated[i][j]);
                    totalallocated[j]+=allocated[i][j];
                  }
                }
                printf("\nEnter the MAX matrix \n     ");
                for (i=0;i< rz;i++) {
                  printf(" %c",(i+97));
                  avail[i]=ins[i]-totalallocated[i];
                }
                printf("\n");
                for (i=0;i < pno;i++) {
                  printf("P[%d]  ",i);
                  for (j=0;j< rz;j++)
                   scanf("%d", &MAX[i][j]);
                }
                printf("\n");
                A: d=-1;
                for (i=0; i < pno;i++) {
                  count=0;
                  t=P[i];
                  for (j=0;j < rz;j++) {
                    need[t][j] = MAX[t][j]-allocated[t][j];
                    if(need[t][j]<=avail[j])
                     count++;
                  }
                  if(count==rz) {
                    output[k++]=P[i];
                    for (j=0;j < rz;j++)
                    avail[j]+=allocated[t][j];
                  } else
                   P[++d]=P[i];
                }
                if(d!=-1) {
                  pno=d+1;
                  goto A;
                }
                  printf("\nSafe Sequence of process : ");
                printf("\t <");
                for (i=0;i < k;i++)
                printf(" P[%d] ",output[i]);
                printf(">");
                
                return 0;
              }
          </code></pre>
          <br>
          <br>

          <span style="font-weight: 700; font-size: 1.375rem;">Characteristics of Bankerâ€™s Algorithm</span>
          <br>
          <br>
          <span style="font-size: 1.25rem;">Here are important characteristics of bankerâ€™s algorithm:&nbsp;<br>â€¢ Keep many resources that satisfy the requirement of at least one client&nbsp;<br>â€¢ Whenever a process gets all its resources, it needs to return them in a
restricted period.&nbsp;<br>â€¢ When a process requests a resource, it needs to wait&nbsp;<br>â€¢ The system has a limited number of resources&nbsp;<br>â€¢ Advance feature for max resource allocation
          </span>
          <br>
          <br>
          <span style="font-size: 1.375rem; font-weight: 700;">Disadvantage of Bankerâ€™s algorithm</span>
          <br>
          <br>&nbsp;<span style="font-size: 1.25rem;">â€¢ Does not allow the process to change its Maximum need while processing&nbsp;<br>â€¢ It allows all requests to be granted in restricted time, but one year is a
fixed period for that.&nbsp;<br>â€¢ All processes must know and state their maximum resource needs in
advance.
          </span>
        </p>
      </div>
    </section>
    <section class="u-clearfix u-section-2" id="sec-7b56">
      <div class="u-clearfix u-sheet u-sheet-1">
        <p class="u-text u-text-default u-text-1" style="font-size: 1.25rem;">
          <span style="font-weight: 700;font-size: 1.25rem;">Example:&nbsp;</span>Consider a system that contains five processes P1, P2, P3, P4, P5 and the three resource types A, B and C. Following are the resources types: A has 10, B has 5 and the resource type C has 7 instances.<br>
          <br>
        </p>
        <img class="u-expanded-width u-image u-image-default u-image-1" src="images/example.png" alt="" data-image-width="1604" data-image-height="664">
      </div>
    </section>
    <section class="u-clearfix u-section-3" id="sec-46aa">
      <div class="u-clearfix u-sheet u-sheet-1">
        <p class="u-text u-text-default u-text-1" style="font-size:1.25rem;">Need [i] = Max [i] - Allocation [i]<br>Need for P1: (7, 5, 3) - (0, 1, 0) = 7, 4, 3<br>Need for P2: (3, 2, 2) - (2, 0, 0) = 1, 2, 2<br>Need for P3: (9, 0, 2) - (3, 0, 2) = 6, 0, 0<br>Need for P4: (2, 2, 2) - (2, 1, 1) = 0, 1, 1<br>Need for P5: (4, 3, 3) - (0, 0, 2) = 4, 3, 1<br>
          <br>Available Resources of A, B and C are 3, 3, and 2.Now we check if each type of resource request is available for each process.<br>Step 1:&nbsp;For Process P1:Need &lt;= Available&nbsp; 7, 4, 3 &lt;= 3, 3, 2&nbsp; condition is&nbsp;false.<br>So, we examine another process, P2.&nbsp;<br>Step 2:&nbsp;For Process P2:Need &lt;= Available 1, 2, 2 &lt;= 3, 3, 2&nbsp; condition&nbsp;true&nbsp;<br>New available = available + Allocation(3, 3, 2) + (2, 0, 0) =&gt; 5, 3, 2&nbsp; &nbsp; Similarly, we examine another process P3.<br>Step 3:&nbsp;For Process P3:P3 Need &lt;= Available6, 0, 0 &lt; = 5, 3, 2 condition is&nbsp;false.<br>Similarly, we examine another process, P4.<br>Step 4:&nbsp;For Process P4:P4 Need &lt;= Available 0, 1, 1 &lt;= 5, 3, 2 condition is&nbsp;true&nbsp;<br>New Available resource = Available + Allocation 5, 3, 2 + 2, 1, 1 =&gt; 7, 4, 3&nbsp;<br>Similarly, we examine another process P5.<br>Step 5:&nbsp;For Process P5:&nbsp; P5 Need &lt;= Available 4, 3, 1 &lt;= 7, 4, 3 condition is&nbsp;true&nbsp;<br>New available resource = Available + Allocation 7, 4, 3 + 0, 0, 2 =&gt; 7, 4, 5&nbsp;<br>Now, we again examine each type of resource request for processes P1 and P3.<br>Step 6:&nbsp;For Process P1:P1 Need &lt;= Available 7, 4, 3 &lt;= 7, 4, 5 condition is&nbsp;true<br>New Available Resource = Available + Allocation 7, 4, 5 + 0, 1, 0 =&gt; 7, 5, 5<br>So, we examine another process P2.<br>Step 7:&nbsp;For Process P3:P3 Need &lt;= Available 6, 0, 0 &lt;= 7, 5, 5 condition is true&nbsp;<br>New Available Resource = Available + Allocation 7, 5, 5 + 3, 0, 2 =&gt; 10, 5, 7 Hence, we execute the banker's algorithm to find the safe state and the safe sequence like P2, P4, P5, P1 and P3.<br>
        </p>
      </div>
    </section>
    <section class="u-clearfix u-section-2" id="sec-ec35">
      <div class="u-clearfix u-sheet u-sheet-1"></div>
    </section>
    
    

  </body>
</html>